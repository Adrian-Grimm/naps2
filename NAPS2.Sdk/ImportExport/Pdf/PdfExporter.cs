using System.Globalization;
using System.Runtime.InteropServices;
using System.Threading;
using NAPS2.ImportExport.Pdf.Pdfium;
using NAPS2.Ocr;
using NAPS2.Scan;
using PdfSharpCore.Drawing;
using PdfSharpCore.Drawing.Layout;
using PdfSharpCore.Pdf;
using PdfSharpCore.Pdf.IO;
using PdfSharpCore.Pdf.Security;
using PdfDocument = PdfSharpCore.Pdf.PdfDocument;
using PdfPage = PdfSharpCore.Pdf.PdfPage;

namespace NAPS2.ImportExport.Pdf;

public class PdfExporter : IPdfExporter
{
    private readonly ScanningContext _scanningContext;

    public PdfExporter(ScanningContext scanningContext)
    {
        _scanningContext = scanningContext;
    }

    public async Task<bool> Export(string path, ICollection<ProcessedImage> images,
        PdfExportParams exportParams, OcrParams? ocrParams = null, ProgressHandler? progressCallback = null,
        CancellationToken cancelToken = default)
    {
        return await Task.Run(async () =>
        {
            // The current iteration of PDF export is fairly complicated. We do a hybrid export using both PdfSharp
            // and Pdfium. "Simple" exports just use PdfSharp. If we have imported PDF pages that are stored as PDFs
            // (i.e. they weren't generated by NAPS2 and can't be extracted to a single image), we use Pdfium to:
            // 1. Check if the pages have text (and therefore are ineligible for OCR).
            // 2. Add those "passthrough" pages to the final PDF file (under certain conditions).
            // For context PdfSharp has a number of bugs with handling arbitrary PDFs, so using Pdfium for exporting
            // those PDF pages lets us avoid those bugs (given we also use Pdfium for importing).
            //
            // Export is also complicated by the fact that we may or may not have OCR enabled, and when it is enabled,
            // we want to parallelize and pipeline the different operations (image rendering, OCR, PDF saving) to
            // maximize performance.

            var document = InitializeDocument(exportParams);

            // TODO: Consider storing text from imported image-based pages in PostProcessingData so it can be saved even
            // when not exporting with OCR (assuming no transforms). 
            var ocrEngine = GetOcrEngine(ocrParams);

            var imagePages = new List<PageExportState>();
            var pdfPages = new List<PageExportState>();

            try
            {
                int pageIndex = 0;
                foreach (var image in images)
                {
                    var pageState = new PageExportState(
                        image, pageIndex++, document, ocrEngine, ocrParams, cancelToken, exportParams.Compat);
                    // TODO: To improve our ability to passthrough, we could consider using Pdfium to apply the transform to
                    // the underlying PDF file. For example, doing color shifting on individual text + image objects, or
                    // applying matrix changes.
                    // TODO: We also can consider doing this even for scanned image transforms - e.g. for deskew, maybe
                    // rather than rasterize that, rely on the pdf to do the skew transform, which should render better at
                    // different scaling.
                    if (IsPdfStorage(image.Storage) && image.TransformState == TransformState.Empty)
                    {
                        pdfPages.Add(pageState);
                    }
                    else
                    {
                        imagePages.Add(pageState);
                    }
                }

                // TODO: Parallelize later
                // TODO: Cancellation and progress reporting
                var imagePagesPipeline = ocrEngine != null
                    ? Pipeline.For(imagePages)
                        .Step(RenderStep)
                        .Step(InitOcrStep)
                        .Step(WaitForOcrStep)
                        .Step(WriteToPdfSharpStep)
                        .Run()
                    : Pipeline.For(imagePages)
                        .Step(RenderStep)
                        .Step(WriteToPdfSharpStep)
                        .Run();

                var pdfPagesPrePipeline = ocrEngine != null
                    ? Pipeline.For(pdfPages).Step(CheckIfOcrNeededStep).Run()
                    : Task.FromResult(pdfPages);

                await pdfPagesPrePipeline;

                var pdfPagesOcrPipeline = Pipeline.For(pdfPages.Where(x => x.NeedsOcr))
                    .Step(RenderStep)
                    .Step(InitOcrStep)
                    .Step(WaitForOcrStep)
                    .Step(WriteToPdfSharpStep)
                    .Run();

                await imagePagesPipeline;
                await pdfPagesOcrPipeline;

                // TODO: Doing in memory as that's presumably faster than IO, but of course that's quite a bit of memory use potentially...
                var stream = FinalizeAndSaveDocument(document, exportParams, out var placeholderPage);

                var passthroughPages = pdfPages.Where(x => !x.NeedsOcr).ToList();
                // TODO: We probably should just use PdfSharp to import the pages, as long as it supports it - just need some tests to cover the case when pdfsharp fails to load a pdf
                // Although it makes me wonder if there are any cases where PdfSharp can mess up an imported file without an error...
                MergePassthroughPages(stream, path, passthroughPages, exportParams, placeholderPage);
            }
            finally
            {
                // TODO: Easier way to handle this?
                foreach (var state in imagePages.Concat(pdfPages))
                {
                    state.RenderedImage?.Dispose();
                }
            }

            return true;
        });
    }

    private void MergePassthroughPages(MemoryStream stream, string path, List<PageExportState> passthroughPages,
        PdfExportParams exportParams, bool placeholderPage)
    {
        if (!passthroughPages.Any())
        {
            if (placeholderPage)
            {
                throw new Exception("No pages to save");
            }
            using var fileStream = new FileStream(path, FileMode.Create);
            stream.CopyTo(fileStream);
            return;
        }
        lock (PdfiumNativeLibrary.Instance)
        {
            // TODO: Need to set a password if needed
            var destBuffer = stream.GetBuffer();
            var destHandle = GCHandle.Alloc(destBuffer, GCHandleType.Pinned);
            try
            {
                var password = exportParams.Encryption.EncryptPdf ? exportParams.Encryption.OwnerPassword : null;
                using var destDoc =
                    Pdfium.PdfDocument.Load(destHandle.AddrOfPinnedObject(), (int) stream.Length, password);
                if (placeholderPage)
                {
                    destDoc.DeletePage(0);
                }
                foreach (var state in passthroughPages)
                {
                    if (state.Image.Storage is ImageFileStorage fileStorage)
                    {
                        using var sourceDoc = Pdfium.PdfDocument.Load(fileStorage.FullPath);
                        CopyPage(destDoc, sourceDoc, state);
                    }
                    else if (state.Image.Storage is ImageMemoryStorage memoryStorage)
                    {
                        var sourceBuffer = memoryStorage.Stream.GetBuffer();
                        var sourceHandle = GCHandle.Alloc(sourceBuffer, GCHandleType.Pinned);
                        try
                        {
                            using var sourceDoc = Pdfium.PdfDocument.Load(sourceHandle.AddrOfPinnedObject(),
                                (int) memoryStorage.Stream.Length);
                            CopyPage(destDoc, sourceDoc, state);
                        }
                        finally
                        {
                            sourceHandle.Free();
                        }
                    }
                }
                destDoc.Save(path);
            }
            finally
            {
                destHandle.Free();
            }
        }
    }

    private void CopyPage(Pdfium.PdfDocument destDoc, Pdfium.PdfDocument sourceDoc, PageExportState state)
    {
        destDoc.ImportPages(sourceDoc, "1", state.PageIndex);
    }

    private static PdfDocument InitializeDocument(PdfExportParams exportParams)
    {
        var document = new PdfDocument();
        var creator = exportParams.Metadata.Creator;
        document.Info.Creator = string.IsNullOrEmpty(creator) ? "NAPS2" : creator;
        document.Info.Author = exportParams.Metadata.Author;
        document.Info.Keywords = exportParams.Metadata.Keywords;
        document.Info.Subject = exportParams.Metadata.Subject;
        document.Info.Title = exportParams.Metadata.Title;

        if (exportParams.Encryption?.EncryptPdf == true
            && (!string.IsNullOrEmpty(exportParams.Encryption.OwnerPassword) ||
                !string.IsNullOrEmpty(exportParams.Encryption.UserPassword)))
        {
            document.SecuritySettings.DocumentSecurityLevel = PdfDocumentSecurityLevel.Encrypted128Bit;
            if (!string.IsNullOrEmpty(exportParams.Encryption.OwnerPassword))
            {
                document.SecuritySettings.OwnerPassword = exportParams.Encryption.OwnerPassword;
            }

            if (!string.IsNullOrEmpty(exportParams.Encryption.UserPassword))
            {
                document.SecuritySettings.UserPassword = exportParams.Encryption.UserPassword;
            }

            document.SecuritySettings.PermitAccessibilityExtractContent =
                exportParams.Encryption.AllowContentCopyingForAccessibility;
            document.SecuritySettings.PermitAnnotations = exportParams.Encryption.AllowAnnotations;
            document.SecuritySettings.PermitAssembleDocument =
                exportParams.Encryption.AllowDocumentAssembly;
            document.SecuritySettings.PermitExtractContent = exportParams.Encryption.AllowContentCopying;
            document.SecuritySettings.PermitFormsFill = exportParams.Encryption.AllowFormFilling;
            document.SecuritySettings.PermitFullQualityPrint =
                exportParams.Encryption.AllowFullQualityPrinting;
            document.SecuritySettings.PermitModifyDocument =
                exportParams.Encryption.AllowDocumentModification;
            document.SecuritySettings.PermitPrint = exportParams.Encryption.AllowPrinting;
        }
        return document;
    }

    private PageExportState RenderStep(PageExportState state)
    {
        var renderedImage = _scanningContext.ImageContext.Render(state.Image);
        var metadata = state.Image.Metadata;
        state.RenderedImage = renderedImage;
        state.FileFormat = ImageFileFormat.Jpeg;
        return state;
    }

    private PageExportState WriteToPdfSharpStep(PageExportState state)
    {
        // TODO: Try and avoid locking somehow
        lock (state.Document)
        {
            // TODO: We need to serialize page adding somehow
            PdfPage page = state.Document.AddPage();
            // TODO: Is there any way we can clean this up?
            var exportFormat = _scanningContext.ImageContext.GetExportFormat(
                state.RenderedImage!, state.Image.Metadata.BitDepth, state.Image.Metadata.Lossless);
            if (exportFormat.FileFormat == ImageFileFormat.Unspecified)
            {
                exportFormat = exportFormat with { FileFormat = ImageFileFormat.Jpeg };
            }
            if (exportFormat.PixelFormat == ImagePixelFormat.BW1 &&
                state.RenderedImage!.PixelFormat != ImagePixelFormat.BW1)
            {
                state.RenderedImage =
                    _scanningContext.ImageContext.PerformTransform(state.RenderedImage, new BlackWhiteTransform());
            }
            DrawImageOnPage(page, state.RenderedImage!, exportFormat, state.Compat);
            // TODO: Maybe split this up to a different step
            if (state.OcrTask?.Result != null)
            {
                DrawOcrTextOnPage(page, state.OcrTask.Result);
            }
        }
        return state;
    }

    private static MemoryStream FinalizeAndSaveDocument(PdfDocument document, PdfExportParams exportParams,
        out bool placeholderPage)
    {
        placeholderPage = false;
        if (document.PageCount == 0)
        {
            document.AddPage();
            placeholderPage = true;
        }

        var compat = exportParams.Compat;
        var now = DateTime.Now;
        document.Info.CreationDate = now;
        document.Info.ModificationDate = now;
        if (compat == PdfCompat.PdfA1B)
        {
            PdfAHelper.SetCidStream(document);
            PdfAHelper.DisableTransparency(document);
        }

        if (compat != PdfCompat.Default)
        {
            PdfAHelper.SetColorProfile(document);
            PdfAHelper.SetCidMap(document);
            PdfAHelper.CreateXmpMetadata(document, compat);
        }

        var stream = new MemoryStream();
        document.Save(stream);
        return stream;
    }

    private IOcrEngine? GetOcrEngine(OcrParams? ocrParams)
    {
        if (ocrParams?.LanguageCode != null)
        {
            var activeEngine = _scanningContext.OcrEngine;
            if (activeEngine == null)
            {
                Log.Error("Supported OCR engine not installed.", ocrParams.LanguageCode);
            }
            else
            {
                return activeEngine;
            }
        }
        return null;
    }

    private PageExportState InitOcrStep(PageExportState state)
    {
        var ext = state.FileFormat == ImageFileFormat.Png ? ".png" : ".jpg";
        string ocrTempFilePath = Path.Combine(_scanningContext.TempFolderPath, Path.GetRandomFileName() + ext);
        if (!_scanningContext.OcrRequestQueue.HasCachedResult(state.OcrEngine!, state.Image, state.OcrParams!))
        {
            // Save the image to a file for use in OCR.
            // We don't need to delete this file as long as we pass it to OcrRequestQueue.Enqueue, which takes 
            // ownership and guarantees its eventual deletion.
            state.RenderedImage!.Save(ocrTempFilePath);
        }

        // Start OCR
        state.OcrTask = _scanningContext.OcrRequestQueue.Enqueue(
            state.OcrEngine!, state.Image, ocrTempFilePath, state.OcrParams!, OcrPriority.Foreground,
            state.CancelToken);
        return state;
    }

    private async Task<PageExportState> WaitForOcrStep(PageExportState state)
    {
        await state.OcrTask!;
        return state;
    }

    private PageExportState CheckIfOcrNeededStep(PageExportState state)
    {
        try
        {
            if (state.Image.Storage is ImageFileStorage fileStorage)
            {
                state.PageDocument = PdfReader.Open(fileStorage.FullPath, PdfDocumentOpenMode.Import);
                state.NeedsOcr = !new PdfiumPdfReader()
                    .ReadTextByPage(fileStorage.FullPath)
                    .Any(x => x.Trim().Length > 0);
            }
            else if (state.Image.Storage is ImageMemoryStorage memoryStorage)
            {
                state.PageDocument = PdfReader.Open(memoryStorage.Stream, PdfDocumentOpenMode.Import);
                state.NeedsOcr = !new PdfiumPdfReader()
                    .ReadTextByPage(memoryStorage.Stream.GetBuffer(), (int) memoryStorage.Stream.Length)
                    .Any(x => x.Trim().Length > 0);
            }
        }
        catch (Exception ex)
        {
            Log.Error("Could not import PDF page for possible OCR, falling back to non-OCR path", ex);
        }
        if (!state.NeedsOcr)
        {
            // TODO: Could also switch around the checks, not sure which order is better
            state.PageDocument?.Close();
        }
        return state;
    }

    private static void DrawOcrTextOnPage(PdfPage page, OcrResult ocrResult)
    {
#if DEBUG && DEBUGOCR
            using XGraphics gfx = XGraphics.FromPdfPage(page, XGraphicsPdfPageOptions.Append);
#else
        using XGraphics gfx = XGraphics.FromPdfPage(page, XGraphicsPdfPageOptions.Prepend);
#endif
        var tf = new XTextFormatter(gfx);
        foreach (var element in ocrResult.Elements)
        {
            if (string.IsNullOrEmpty(element.Text)) continue;

            var adjustedBounds = AdjustBounds(element.Bounds, (float) page.Width / ocrResult.PageBounds.w,
                (float) page.Height / ocrResult.PageBounds.h);
#if DEBUG && DEBUGOCR
                    gfx.DrawRectangle(new XPen(XColor.FromArgb(255, 0, 0)), adjustedBounds);
#endif
            var adjustedFontSize = CalculateFontSize(element.Text, adjustedBounds, gfx);
            // Special case to avoid accidentally recognizing big lines as dashes/underscores
            if (adjustedFontSize > 100 && (element.Text == "-" || element.Text == "_")) continue;
            var font = new XFont("Times New Roman", adjustedFontSize, XFontStyle.Regular,
                new XPdfFontOptions(PdfFontEncoding.Unicode));
            var adjustedTextSize = gfx.MeasureString(element.Text, font);
            var verticalOffset = (adjustedBounds.Height - adjustedTextSize.Height) / 2;
            var horizontalOffset = (adjustedBounds.Width - adjustedTextSize.Width) / 2;
            adjustedBounds.Offset((float) horizontalOffset, (float) verticalOffset);
            tf.DrawString(element.RightToLeft ? ReverseText(element.Text) : element.Text, font, XBrushes.Transparent,
                adjustedBounds);
        }
    }

    private static string ReverseText(string text)
    {
        TextElementEnumerator enumerator = StringInfo.GetTextElementEnumerator(text);
        List<string> elements = new List<string>();
        while (enumerator.MoveNext())
        {
            elements.Add(enumerator.GetTextElement());
        }
        elements.Reverse();
        return string.Concat(elements);
    }

    private void DrawImageOnPage(PdfPage page, IMemoryImage image, ImageExportFormat exportFormat, PdfCompat compat)
    {
        using var xImage = XImage.FromImageSource(new ImageSource(image, exportFormat));
        if (compat != PdfCompat.Default)
        {
            xImage.Interpolate = false;
        }
        var (realWidth, realHeight) = GetRealSize(image);
        page.Width = realWidth;
        page.Height = realHeight;
        using XGraphics gfx = XGraphics.FromPdfPage(page);
        gfx.DrawImage(xImage, 0, 0, realWidth, realHeight);
    }

    private static (int width, int height) GetRealSize(IMemoryImage img)
    {
        double hAdjust = 72 / img.HorizontalResolution;
        double vAdjust = 72 / img.VerticalResolution;
        if (double.IsInfinity(hAdjust) || double.IsInfinity(vAdjust))
        {
            hAdjust = vAdjust = 0.75;
        }
        double realWidth = img.Width * hAdjust;
        double realHeight = img.Height * vAdjust;
        return ((int) realWidth, (int) realHeight);
    }

    private static XRect AdjustBounds((int x, int y, int w, int h) bounds, float hAdjust, float vAdjust) =>
        new XRect(bounds.x * hAdjust, bounds.y * vAdjust, bounds.w * hAdjust, bounds.h * vAdjust);

    private static int CalculateFontSize(string text, XRect adjustedBounds, XGraphics gfx)
    {
        int fontSizeGuess = Math.Max(1, (int) (adjustedBounds.Height));
        var measuredBoundsForGuess =
            gfx.MeasureString(text, new XFont("Times New Roman", fontSizeGuess, XFontStyle.Regular));
        double adjustmentFactor = adjustedBounds.Width / measuredBoundsForGuess.Width;
        int adjustedFontSize = Math.Max(1, (int) Math.Floor(fontSizeGuess * adjustmentFactor));
        return adjustedFontSize;
    }

    private static bool IsPdfStorage(IImageStorage storage) => storage switch
    {
        ImageFileStorage fileStorage => Path.GetExtension(fileStorage.FullPath).ToLowerInvariant() == ".pdf",
        ImageMemoryStorage memoryStorage => memoryStorage.TypeHint == ".pdf",
        _ => false
    };

    private class PageExportState
    {
        public PageExportState(ProcessedImage image, int pageIndex, PdfDocument document, IOcrEngine? ocrEngine,
            OcrParams? ocrParams, CancellationToken cancelToken, PdfCompat compat)
        {
            Image = image;
            PageIndex = pageIndex;
            Document = document;
            OcrEngine = ocrEngine;
            OcrParams = ocrParams;
            CancelToken = cancelToken;
            Compat = compat;
        }

        public ProcessedImage Image { get; }
        public int PageIndex { get; }

        public PdfDocument Document { get; }
        public IOcrEngine? OcrEngine { get; }
        public OcrParams? OcrParams { get; }
        public CancellationToken CancelToken { get; }
        public PdfCompat Compat { get; }

        public bool NeedsOcr { get; set; }
        public IMemoryImage? RenderedImage { get; set; }
        public ImageFileFormat FileFormat { get; set; }
        public Task<OcrResult?>? OcrTask { get; set; }
        public PdfDocument? PageDocument { get; set; }
    }

    private class ImageSource : IImageSource
    {
        private readonly IMemoryImage _image;
        private readonly ImageExportFormat _exportFormat;

        public ImageSource(IMemoryImage image, ImageExportFormat exportFormat)
        {
            _image = image;
            _exportFormat = exportFormat;
        }

        public void SaveAsJpeg(MemoryStream ms)
        {
            _image.Save(ms, ImageFileFormat.Jpeg);
        }

        public unsafe void SaveAsPdfBitmap(MemoryStream ms)
        {
            var bytesPerPixel = _image.PixelFormat switch
            {
                ImagePixelFormat.ARGB32 => 4,
                ImagePixelFormat.RGB24 => 3,
                _ => throw new InvalidOperationException("Expected 24 or 32 bit bitmap")
            };
            int height = _image.Height;
            int width = _image.Width;
            ms.SetLength(height * width * bytesPerPixel);
            var buffer = ms.GetBuffer();
            using var data = _image.Lock(LockMode.ReadOnly, out var scan0, out var stride);
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    var pixelData = (byte*) (scan0 + y * stride + x * bytesPerPixel);
                    int bufferIndex = ((height - y - 1) * width + x) * bytesPerPixel;
                    buffer[bufferIndex] = *pixelData;
                    buffer[bufferIndex + 1] = *(pixelData + 1);
                    buffer[bufferIndex + 2] = *(pixelData + 2);
                    if (bytesPerPixel == 4)
                    {
                        buffer[bufferIndex + 3] = *(pixelData + 3);
                    }
                }
            }
        }

        public unsafe void SaveAsPdfIndexedBitmap(MemoryStream ms)
        {
            if (_image.PixelFormat != ImagePixelFormat.BW1)
                throw new InvalidOperationException("Expected 1 bit bitmap");
            int height = _image.Height;
            int width = _image.Width;
            int bytesPerRow = (width - 1) / 8 + 1;
            ms.SetLength(height * bytesPerRow);
            var buffer = ms.GetBuffer();
            using var data = _image.Lock(LockMode.ReadOnly, out var scan0, out var stride);
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < bytesPerRow; x++)
                {
                    var pixelData = (byte*) (scan0 + y * stride + x);
                    buffer[(height - y - 1) * bytesPerRow + x] = *pixelData;
                }
            }
        }

        public int Width => _image.Width;
        public int Height => _image.Height;
        public string? Name => null;

        public XImageFormat ImageFormat
        {
            get
            {
                if (_exportFormat.FileFormat == ImageFileFormat.Jpeg)
                {
                    return XImageFormat.Jpeg;
                }
                if (_exportFormat.PixelFormat == ImagePixelFormat.BW1)
                {
                    return XImageFormat.Indexed;
                }
                if (_exportFormat.PixelFormat == ImagePixelFormat.ARGB32)
                {
                    return XImageFormat.Argb32;
                }
                if (_exportFormat.PixelFormat == ImagePixelFormat.RGB24)
                {
                    return XImageFormat.Rgb24;
                }
                throw new Exception("Unsupported pixel format");
            }
        }
    }
}